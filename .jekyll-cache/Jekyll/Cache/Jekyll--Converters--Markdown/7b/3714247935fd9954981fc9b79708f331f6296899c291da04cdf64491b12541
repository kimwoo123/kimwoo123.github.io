I"s<h1 id="웹-렌더링의-과정">웹 렌더링의 과정</h1>

<h2 id="crp">CRP</h2>

<hr />

<p>브라우저가 서버에서 페이지에 대한 응답을 받으면 화면에 표시되기 까지 많은 단계를 거친다. 브라우저가 페이지의 초기 출력을 위해 실행해야하는 이 순서를 CRP(Critical Rendering Path)라고 한다. CRP를 최적화 하면 최초 페이지 렌더링에 걸리는 시간이 상당히 단축된다.</p>

<p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/progressive-rendering.png?hl=ko" alt="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/progressive-rendering.png?hl=ko" /></p>

<p>CRP는 6단계로 구성되어 있다.</p>

<ul>
  <li>DOM 트리 구축</li>
  <li>CSSOM 트리 구축</li>
  <li>JavaScript 실행</li>
  <li>렌더링 트리 구축</li>
  <li>레이아웃 생성</li>
  <li>페인팅</li>
</ul>

<h3 id="raw-bytes-of-data">raw bytes of data</h3>

<hr />

<p>서버에 요청을 보내면 서버는 응답과 함께 데이터를 보내준다. 컴퓨터는 0과 1밖에 이해하지 못하기 때문에 브라우저는 바이트화 된 데이터를 받아온다. 바이트화 된 데이터는 8자리의 2진수이며 이를 2자리의 16진수로 나타낸 것이 밑에 보이는 hex-view이다.</p>

<p><img src="%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20d1b1327c75ea43219b88357ad9ca4d32/hex_view.jpg" alt="%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20d1b1327c75ea43219b88357ad9ca4d32/hex_view.jpg" /></p>

<p>fiddler을 사용하여 구글에 접속할 때 보낸 request와 받은 response를 16진수로 나타낸 것이다.</p>

<p>바이트화 된 데이터를 인코딩하여 브라우저가 사용할 수 있도록 Characters로 변환된다. 인코딩 페이지에서 이어진다.</p>

<h3 id="dom">DOM</h3>

<hr />

<p>Document Object Model은 원본 HTML 문서의 객체 기반 표현 방식이다. 둘은 서로 비슷하지만, DOM이 갖고 있는 근본적인 차이는 단순 텍스트로 구성된 HTML 문서의 내용과 구조가 객체 모델로 변환되어 다양한 프로그램에서 사용된다는 점이다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
 <span class="nt">&lt;head&gt;</span>
   <span class="nt">&lt;title&gt;</span>My first web page<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
 <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Hello, world!<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;p&gt;</span>How are you?<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><img src="%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20d1b1327c75ea43219b88357ad9ca4d32/DOM.jpg" alt="%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20d1b1327c75ea43219b88357ad9ca4d32/DOM.jpg" /></p>

<p>단순한 텍스트였던 HTML 문서는 위와 같은 노드 트리로 표현된다.</p>

<h3 id="dom-tree">DOM tree</h3>

<hr />

<ul>
  <li>브라우저가 DOM 트리를 만드는 순서는 다음과 같다.
    <ul>
      <li>바이트 → 문자 → 토큰 → 노드 → 객체 모델.</li>
    </ul>
  </li>
</ul>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
  <span class="nt">&lt;head&gt;</span>
    <span class="nt">&lt;meta</span> <span class="na">name=</span><span class="s">"viewport"</span> <span class="na">content=</span><span class="s">"width=device-width,initial-scale=1"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;link</span> <span class="na">href=</span><span class="s">"style.css"</span> <span class="na">rel=</span><span class="s">"stylesheet"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;title&gt;</span>Critical Path<span class="nt">&lt;/title&gt;</span>
  <span class="nt">&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;p&gt;</span>Hello <span class="nt">&lt;span&gt;</span>web performance<span class="nt">&lt;/span&gt;</span> students!<span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;div&gt;&lt;img</span> <span class="na">src=</span><span class="s">"awesome-photo.jpg"</span><span class="nt">&gt;&lt;/div&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png?hl=ko" alt="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png?hl=ko" /></p>

<ol>
  <li>Bytes → Characters 변환
    <ul>
      <li>브라우저가 HTML의 원시 바이트를 네트워크에서 읽어와서, 해당 파일에 대해 지정된 인코딩(UTF-8)에 따라 개별 문자로 변환한다.</li>
    </ul>
  </li>
  <li>Characters → Tokens 토큰화
    <ul>
      <li>브라우저가 문자열을 <a href="https://html.spec.whatwg.org/#parsing-main-inhtml">W3C HTML5 표준</a>에 지정된 고유 토큰으로 변환한다.</li>
      <li>
        <p>파싱 알고리즘 (블로그 전문 인용)</p>

        <p>## 브라우저의 html 오류 유형</p>

        <p>참고 사이트 : <a href="https://d2.naver.com/helloworld/59361">https://d2.naver.com/helloworld/59361</a></p>

        <p>위 사이트의 파싱 알고리즘 부터 읽어봤다.</p>

        <p><a href="http://htmlcxx.sourceforge.net/">http://htmlcxx.sourceforge.net/</a> &gt; c++ html 파서</p>

        <p>## 파싱 알고리즘</p>

        <p>HTML 은 일반적인 하향식 또는 상향식 파서로 파싱이 안되는데 이유는 다음과 같다.</p>

        <ol>
          <li>언어의 너그러운 속성.</li>
          <li>잘 알려져 있는 HTML 오류에 대한 브라우저의 관용</li>
          <li>변경에 의한 재파싱. 일반적으로 소스는 파싱하는 동안 변하지 않지만 HTML 에서 document.write 을 포함하고 있는스크립트 태그는 토큰을 추가할 수 있기 때문에 실제로는 입력 과정에서 파싱이 수정된다.일반적인 파싱 기술을 사용할 수 없기 때문에 브라우저는 HTML 파싱을 위해 별도의 파서를 생성한다.</li>
        </ol>

        <p><a href="https://html.spec.whatwg.org/multipage/parsing.html">https://html.spec.whatwg.org/multipage/parsing.html</a> &gt; 파싱 알고리즘 설명 페이지</p>

        <p>초기 상태는 “자료 상태” 이다. &lt; 문자를 만나면 상태는 “태그 열림 상태”로 변한다. a 부터 z까지의 문자를 만나면 “시작</p>

        <p>태그 토큰”을 생성하고 상태는 “태그 이름 상태”로 변하는데 이 상태는 &gt; 문자를 만날 때까지 유지한다. 각 문자에는 새로운 토큰 이름이 붙는데 이 경우 생성된 토큰은 html 토큰이다.</p>

        <blockquote>
          <p>문자에 도달하면 현재 토큰이 발행되고 상태는 다시 “자료 상태”로 바뀐다.</p>
        </blockquote>

        <p>태그는 동일한 절차에 따라 처리된다. 지금까지 html 태그와 body 태그를 발행했고 다시 “자료 상태”로 돌아왔다.</p>

        <p>Hello World의 H 문자를 만나면 문자 토큰이 생성되고 발행될 것이다. 이것은 종료 태그의 &lt; 문자를 만날 때까지 진행된다. Hello World의 각 문자를 위한 문자 토큰을 발행할 것이다.</p>

        <p>다시 “태그 열림 상태”가 되었다. / 문자는 종료 태그 토큰을 생성하고 “태그 이름 상태”로 변경 될 것이다. 이 상태는 &gt; 문자를 만날 때까지 유지된다. 그리고 새로운 태그 토큰이 발행되고 다시 “자료 상태”가 된다. 또한 동일하게 처리될 것이다.</p>

        <p>### 브라우저의 오류 처리</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;html&gt;
    &lt;mytag&gt;&lt;/mytag&gt;
    &lt;div&gt;
      &lt;p&gt;
    &lt;/div&gt;
    Really lousy HTML
    &lt;/p&gt;
  &lt;/html&gt;
</code></pre></div>        </div>

        <p>mytag 는 표준 태그가 아니고 “p” 태그와 “div” 태그는 중첩 오류가 있다. 그러나 브라우저는 투덜거리지 않고 올바르게 표시한다.</p>

        <p>이는 파서가 HTML 제작자의 실수를 수정했기 때문이다.</p>

        <p>파서는 적어도 다음과 같은 오류를 처리해야 한다.</p>

        <ol>
          <li>어떤 태그의 안쪽에 추가하려는 태그가 금지된 것일 때 일단 허용된 태그를 먼저 닫고 금지된 태그는 외부에 추가한다.</li>
          <li>파서가 직접 요소를 추가해서는 안된다. 문서 제작자에 의해 뒤늦게 요소가 추가될 수 있고 생략 가능한 경우도 있다.HTML, HEAD, BODY, TBODY, TR, TD, LI 태그가 이런 경우에 해당한다.</li>
          <li>인라인 요소 안쪽에 블록 요소가 있는 경우 부모 블록 요소를 만날 때까지 모든 인라인 태그를 닫는다.</li>
          <li>이런 방법이 도움이 되지 않으면 태그를 추가하거나 무시할 수 있는 상태가 될 때까지 요소를 닫는다.웹킷이 오류를 처리하는 예는 다음과 같다.</li>
        </ol>

        <p>### 대신</p>

        <p>어떤 사이트는대신을 사용한다. 인터넷 익스플로러, 파이어폭스와 호환성을 갖기 위해 웹킷은 이것을으로 간주한다.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   if(t-&gt;isCloseTag(brTag) &amp;&amp; m_document-&gt;inCompatMode()) {
      reportError(MalformedBRError);
      t-&gt;beginTag = true;
  }

</code></pre></div>        </div>

        <p>오류는 내부적으로 처리하고 사용자에게는 표시하지 않는다.</p>

        <p>### 어긋난 표</p>

        <p>어긋난 표는 표 안에 또 다른 표가 th 또는 td 셀 내부에 있지 않은 것을 의미한다. 아래 예제와 같은 경우를 말한다.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;table&gt;

      &lt;table&gt;

      &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;

      &lt;/table&gt;

      &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;

  &lt;/table&gt;
</code></pre></div>        </div>

        <p>이런 경우 웹킷은 표의 중첩을 분해하여 형제 요소가 되도록 처리한다.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  &lt;table&gt;

      &lt;tr&gt;&lt;td&gt;outer table&lt;/td&gt;&lt;/tr&gt;

  &lt;/table&gt;

  &lt;table&gt;

      &lt;tr&gt;&lt;td&gt;inner table&lt;/td&gt;&lt;/tr&gt;

  &lt;/table&gt;
</code></pre></div>        </div>

        <p>코드는 다음과 같다.</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  if(m_inStrayTableContent &amp;&amp; localName == tableTag)
  popBlock(tableTag);
</code></pre></div>        </div>

        <p>웹킷은 이런 오류를 처리하는데 스택을 사용한다. 안쪽의 표는 바깥쪽 표의 외부로 옮겨져서 형제 요소가 된다.</p>

        <p>### 중첩된 폼 요소</p>

        <p>폼 안에 또 다른 폼을 넣은 경우 안쪽의 폼을 무시된다.</p>

        <p>### 태그 중첩이 너무 깊을 때</p>

        <p>www.liceo.edu.mx 사이트는 약 1,500 개 수준의 태그 중첩이 되어 있는 예제인데 모든 요소가 <strong>로 되어있다.</strong></p>

        <p><strong>최대 20개의 중첩만 허용하고 나머지는 무시한다.</strong></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  **bool HTMLParser::allowNestedRedundantTag(const AtomicString&amp; tagName) 
  {
          
      unsigned i = 0;
      for (HTMLStackElem* curr = m_blockStack;
          i &lt; cMaxRedundantTagDepth &amp;&amp; curr &amp;&amp; curr-&gt;tagName == tagName; 
          curr = curr-&gt;next, i++) { }
      return i != cMaxRedundantTagDepth;
  }**
</code></pre></div>        </div>

        <p><strong>**잘 못 닫힌 html 또는 body 태그
  깨진 html 을 지원한다. 일부 바보 같은 페이지는 문서가 끝나기 전에 body 를 닫아버리기 때문에 브라우저는 body 태그를 닫지 않는다. 대신 종료를 위해 end() 를 호출한다.</strong>**</p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  **if (t-&gt;tagName == htmlTag || t-&gt;tagName == bodyTag ) 
     return;**
</code></pre></div>        </div>

        <p><strong>• 안 닫힌 태그, 안 닫힌 따옴표 등에 대해 블링크나 웹킷은 어떻게 처리하고 있는지 알아볼 것</strong></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
  **unexpected-character-in-unquoted-attribute-value
  This error occurs if the parser encounters a U+0022 ("), U+0027 ('), U+003C (&lt;), U+003D (=), or U+0060 (`) code point in an unquoted attribute value.
  The parser includes such code points in the attribute value.
  Code points that trigger this error are usually a part of another syntactic construct and can be a sign of a typo around the attribute value.
  U+0060 (`) is in the list of code points that trigger this error because certain legacy user agents treat it as a quote.
  For example, consider the following markup:
  &lt;div foo=b'ar'&gt;
  Due to a misplaced U+0027 (') code point the parser sets the value of the "foo" attribute to "b'ar'".**
</code></pre></div>        </div>

        <p><strong>• encoding 을 어떻게 할 것인가…
  • 태그의 의미를 존중하는 html 필터 만들기 - streaming 방식…
  • 태그 사이에 나오는 텍스트 필터링 되지 않도록 수정
  • html 주석도 처리해야 한다* 확인하여 내용 누락 할 수 있도록 구성
  • tag 와 함께 나오는 attribute 도 처리해야 한다* chromiun 의 경우 자주 쓰이는 tag 들에 대해서 별도로 tokenizer 를 하고 있다.</strong></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  **// This is a direct transcription of step 4 from:
  // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#fragment-case
         
  static HTMLTokenizer::State tokenizerStateForContextElement(Element* contextElement, bool reportErrors, const HTMLParserOptions&amp; options)
         
  {
         
      if (!contextElement)
         
          return HTMLTokenizer::DataState;
         
         
      const QualifiedName&amp; contextTag = contextElement-&gt;tagQName();
         
         
      if (contextTag.matches(titleTag) || contextTag.matches(textareaTag))
         
          return HTMLTokenizer::RCDATAState;
         
      if (contextTag.matches(styleTag)
         
          || contextTag.matches(xmpTag)
         
          || contextTag.matches(iframeTag)
         
          || (contextTag.matches(noembedTag) &amp;&amp; options.pluginsEnabled)
         
          || (contextTag.matches(noscriptTag) &amp;&amp; options.scriptEnabled)
         
          || contextTag.matches(noframesTag))
         
          return reportErrors ? HTMLTokenizer::RAWTEXTState : HTMLTokenizer::PLAINTEXTState;
         
      if (contextTag.matches(scriptTag))
         
          return reportErrors ? HTMLTokenizer::ScriptDataState : HTMLTokenizer::PLAINTEXTState;
         
      if (contextTag.matches(plaintextTag))
         
          return HTMLTokenizer::PLAINTEXTState;
         
      return HTMLTokenizer::DataState;
         
  }**
</code></pre></div>        </div>

        <p><strong>• <a href="https://github.com/waylan/beautifulsoup/blob/master/bs4/builder/_htmlparser.py">https://github.com/waylan/beautifulsoup/blob/master/bs4/builder/_htmlparser.py</a> - beautiful soup 코드를 참고한다.
  • 크로미움이나 c++ 소스는 너무 어렵당…<em>처음 가정은 attribute 내용은 꺽쇠를 만날 때 까지 모두 skip 을 할 생각이었다.</em>하지만 문서 중 아래와 같은 문서가 있어 위의 방법은 쓸 수가 없었다.</strong></p>

        <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div>        </div>
        <p>**  <input class="download_button" onclick="javascript:urchinTracker('/downloads/314375');" type="submit" name="download" value="--&gt; Stáhnout soubor &lt;--" />**
  ```</p>

        <p>**• beautiful soup 의 경우 정규식을 쓰고있는데 우리는 정규식을 쓸 수가 없으므로 코드로 beautiful soup 이 하는 일을 흉내내본다.</p>
        <ol>
          <li>여는 꺽쇠 ‘&lt;’ 부터 시작</li>
          <li>tag name</li>
          <li>tag name 다음에 white space 가 나오면 attribute 앞의 white space 로 간주</li>
          <li>white space 다음에 나오는 글자는 attribute 이름</li>
          <li>’=’ 가 나온다</li>
          <li>’=’ 다음은 ‘’ 이거나 “” 이다.</li>
          <li>또 white space 가 있는지 검사한다.</li>
          <li>없다면 ‘/’ 가 있는지 확인하고 tag 파싱을 종료한다
  • 짝이 안맞는 태그 처리<em>짝이 안맞는 태그의 경우 tag 를 저장하고 있는 stack 을 뒤져 맞는 태그를 발견하는 경우 해당 위치 까지 있는 stack 의 태그를 모두 지운다.</em>지워진 태그로인해 짝이 안맞게 되는 경우 닫는 태그 형태를 하고 있으면 해당 태그는 skip 한다
  • 태그 처리<em>의 경우or이렇게 태그가 입력 될 수 도 있다는 점을 고려한다.
  • 
  • html 개행</em> ‘\n’ 을 만나는 경우 중복은 개행은 하나의 공백으로 처리한다**</li>
        </ol>
      </li>
    </ul>

    <p><a href="https://velog.io/@keis2957/HTML-%ED%8C%8C%EC%84%9C">HTML 파서</a></p>
  </li>
  <li>Tokens → Nodes 렉싱
    <ul>
      <li>방출된 토큰은 해당 속성 및 규칙을 정의하는 ‘객체’로 변환된다.</li>
    </ul>
  </li>
  <li>Tokens → DOM 생성
    <ul>
      <li>HTML 마크업이 여러 태그 간의 관계를 정의하기 때문에 생성된 객체는 트리 데이터 구조 내에 연결된다. 이 트리 데이터 구조에는 원래 마크업에 정의된 상위-하위 관계도 포함된다.</li>
    </ul>
  </li>
</ol>

<h3 id="dom의-특징">DOM의 특징</h3>

<hr />

<p><strong>DOM이 HTML과 반드시 연결되어 있는 것은 아니다</strong></p>

<ol>
  <li>작성된 HTML 문서가 유효하지 않을 때
    <ul>
      <li>브라우저는 DOM을 생성하는 동안, 유효하지 않은 HTML 코드를 올바르게 교정한다.</li>
    </ul>

    <div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">&lt;!doctype html&gt;</span>
 <span class="nt">&lt;html&gt;</span>
 Hello, world!
 <span class="nt">&lt;/html&gt;</span>
</code></pre></div>    </div>

    <p><img src="%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20d1b1327c75ea43219b88357ad9ca4d32/DOM2.jpg" alt="%E1%84%8B%E1%85%B0%E1%86%B8%20%E1%84%85%E1%85%A6%E1%86%AB%E1%84%83%E1%85%A5%E1%84%85%E1%85%B5%E1%86%BC%E1%84%8B%E1%85%B4%20%E1%84%80%E1%85%AA%E1%84%8C%E1%85%A5%E1%86%BC%20d1b1327c75ea43219b88357ad9ca4d32/DOM2.jpg" /></p>

    <p>DOM 트리는 올바르게 교정되어 나타낸다.</p>
  </li>
  <li>자바스크립에 의해 DOM이 수정될 때
    <ul>
      <li>DOM은 HTML 문서의 내용을 볼 수 있는 인터페이스 역할을 하는 동시에 동적 자원으로써 변경이 가능하다.</li>
    </ul>

    <div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">newParagraph</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="dl">"</span><span class="s2">p</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">var</span> <span class="nx">paragraphContent</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="dl">"</span><span class="s2">I'm new!</span><span class="dl">"</span><span class="p">);</span>
<span class="nx">newParagraph</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">paragraphContent</span><span class="p">);</span>
<span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">newParagraph</span><span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><strong>우리가 브라우저에서 보는 것은 정확히는 DOM이 아니라 render 트리이다.</strong></p>

<p>render 트리는 DOM 과 CSSOM 을 결합한 것으로, 오직 스크린에 그려지는 것으로 구성되어 있어 DOM과 다르다. 렌더 트리에는 렌더링 되는 요소만을 담기 때문에 시각적으로 보이지 않는 요소는 제외된다.</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!doctype html&gt;</span>
<span class="nt">&lt;html</span> <span class="na">lang=</span><span class="s">"en"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;head&gt;&lt;/head&gt;</span>
  <span class="nt">&lt;body&gt;</span>
    <span class="nt">&lt;h1&gt;</span>Hello, world!<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;p</span> <span class="na">style=</span><span class="s">"display: none;"</span><span class="nt">&gt;</span>How are you?<span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p><strong>개발자 도구에 있는 것은 DOM이 아니다.</strong></p>

<p>개발자 도구의 Elements 탭은 DOM과 아주 비슷한 결과를 보여준다. 그러나 개발자 도구 에서는 DOM보다 추가적인 요소를 보여준다.</p>

<p>가장 좋은 예는 CSS 의사 요소(pseudo-elements)이다. ::before과 ::after 선택자를 사용하여 생성된 의사 요소는 CSSOM과 렌더 트리의 일부를 구성한다.</p>

<p>DOM은 오직 원본 HTML 문서로부터 빌드 되고, 요소에 적용되는 스타일을 포함하지 않는다.</p>

<p>의사 요소는 DOM에 포함되지 않음에도 불구하고, 개발자 도구의 Elements 탭에는 포함되어 나타난다</p>

<p><img src="https://bitsofco.de/content/images/2018/11/Pseudo-element-in-devtools-inspector.png" alt="https://bitsofco.de/content/images/2018/11/Pseudo-element-in-devtools-inspector.png" /></p>

<p>::after 선택자는 DOM에 포함되지 않지만 개발자 도구에는 표시되어 있다.</p>

<table>
  <tbody>
    <tr>
      <td>[DOM은 정확히 무엇일까?</td>
      <td>WIT블로그](https://wit.nts-corp.com/2019/02/14/5522)</td>
    </tr>
  </tbody>
</table>

<p><a href="https://bitsofco.de/what-exactly-is-the-dom/?utm_source=CSS-Weekly&amp;utm_campaign=Issue-341&amp;utm_medium=email">What, exactly, is the DOM?</a></p>

<table>
  <tbody>
    <tr>
      <td>[객체 모델 생성</td>
      <td>Web Fundamentals</td>
      <td>Google Developers](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko)</td>
    </tr>
  </tbody>
</table>

<h3 id="cssom">CSSOM</h3>

<hr />

<p>CSS Object Model은 DOM과 유사한 스타일의 Object 표현이다. 브라우저는 단순한 페이지의 DOM을 생성하는 동안 외부 CSS 스타일 시트인 style.css를 참조하는 문서의 헤드 섹션에서 링크 태그를 접한다. 페이지를 렌더링 하는데 이 리소스가 필요할 것이라고 판단한 브라우저는 리소스에 대한 요청을 즉시 발송하고 요청의 결과로 다음 콘텐츠가 반환된다.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">body</span> <span class="p">{</span> <span class="nl">font-size</span><span class="p">:</span> <span class="m">16px</span> <span class="p">}</span>
<span class="nt">p</span> <span class="p">{</span> <span class="nl">font-weight</span><span class="p">:</span> <span class="nb">bold</span> <span class="p">}</span>
<span class="nt">span</span> <span class="p">{</span> <span class="nl">color</span><span class="p">:</span> <span class="no">red</span> <span class="p">}</span>
<span class="nt">p</span> <span class="nt">span</span> <span class="p">{</span> <span class="nl">display</span><span class="p">:</span> <span class="nb">none</span> <span class="p">}</span>
<span class="nt">img</span> <span class="p">{</span> <span class="nl">float</span><span class="p">:</span> <span class="nb">right</span> <span class="p">}</span>
</code></pre></div></div>

<p>HTML과 마찬가지로 수신된 CSS 규칙을 브라우저가 이해하고 처리할 수 있는 형식으로 변환해야 한다. 따라서 CSS에 대해 HTML 프로세스를 반복한다.</p>

<p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png?hl=ko" alt="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png?hl=ko" /></p>

<p><img src="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png?hl=ko" alt="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png?hl=ko" /></p>

<p>CSSOM이 트리 구조를 가지는 이유는 무엇일까? 페이지에 있는 객체의 최종 스타일을 계산할 때 브라우저는 해당 노드에 적용 가능한 가장 일반적인 규칙으로 시작한 후 더욱 구체적인 규칙을 적용하는  방식, 즉 ‘하향식’으로 규칙을 적용하여 계산된 스타일을 재귀적으로 세분화한다. HTML과 달리 CSS는 계단식 상속 특성 때문에 부분적으로 실행될 수 없다. 문서의 뒷부분에 정의된 스타일은 이전에 정의된 스타일을 무시하고 변경할 수 있다. 따라서 스타일 시트 전체가 파싱되어야 다음 단계로 넘어갈 수 있다. (<a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=ko">렌더링 차단 리소스</a>)</p>

<p>위의 그림에서 body 요소 내에 있는 span 태그 안에 포함된 모든 텍스트의 크기는 16픽셀이고 색상은 빨간색이다. font-size 지시문은 body에서 span으로 하향식을 적용되기 때문이다. 하지만 span 태그가 단락&lt;p&gt; 태그의 하위인 경우 해당 콘텐츠는 표시되지 않는다(display: none).</p>

<p>또한, 위의 트리는 완전한 CSSOM 트리가 아니고 스타일시트에서 재정의하도록 결정한 스타일만 표시한다는 점에 유의해야한다. 모든 브라우저는 ‘사용자 에이전트 스타일’이라고 하는 기본 스타일 집합, 즉 개발자가 고유한 스타일을 제공하지 않을 경우 표시되는 스타일을 제공한다. 개발자가 작성하는 스타일은 이러한 <a href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/renderer/core/html/resources/html.css">기본 스타일</a>을 간단하게 재정의한다.</p>

<h3 id="javascript-실행">JavaScript 실행</h3>

<hr />

<p>JavaScript는 파서 차단 리소스이다. 이 말은 HTML 문서의 파싱이 JavaScript에 의해 차단된다는 뜻이다.</p>

<p>파서가 <script>태그에 도달(내부적으로도 외부적으로도) 하면 페치를 멈추고 실행한다. 따라서 문서 내의 요소를 참조하는 JavaScript 파일이 있는 경우 해당 문서가 표시된 후에 배치해야 한다.</script></p>

<p><a href="https://html.spec.whatwg.org/multipage/parsing.html#parsing">HTML</a></p>
:ET